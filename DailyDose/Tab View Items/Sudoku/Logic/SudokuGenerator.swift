//
//  SudokuGenerator.swift
//  DailyDose
//
//  Created by Aaron Gomez on 12/4/23.
//  Copyright Â© 2023 CS3714 Team 2. All rights reserved.
//

import Foundation

// **********************************************************************
// This file is my implementation of the functions necessary to generate
// random Sudoku. I greatly underestimated the complexity of the puzzle,
// so some approaches are probably naive solutions. To avoid ambiguity, I
// will stick to the terminology used in Wikipedia's Glossary of Sudoku:
// https://en.wikipedia.org/wiki/Glossary_of_Sudoku
// **********************************************************************

// Randomly generates a valid Sudoku grid. This implementation takes advantage
// of the Sudoku rules and the properties emerging from them:
//
//  1. The first row is a random permutation of the numbers 1-9
//  2. A valid band can be formed from this row by simply rotating the next two
//      rows by 3 and 6, respectively. Another multiple of 3 cannot be used to
//      to start the next band because it would match the first row, so instead
//      a rotation of 1 is used (this process works for the last band as well).
//  3. The grid is now valid, but users will very likely notice the patterns
//      created by this generation process. Luckily, bands/stacks and the
//      rows/columns (only inside each!) can be freely rearranged to break this
//      repetition without violating the grid's validity.
//
// This generation algorithm takes inspiration from the strategy described on
// StackExchange by Jack G and Yaling Zheng:
// https://gamedev.stackexchange.com/a/138228
public func generateFullSudokuGrid() -> [[Int]] {
    var values = [[Int]]()

    // Start with a random permutation of 1-9 for the first row
    values.append(Array(1...9))
    values[0].shuffle()

    // Next rows can be generated with clever use of rotations
    for i in 1...8 {
        values.append(values[i-1].rotate(by: (i % 3 == 0) ? 1 : 3))
    }

    // Shuffle rows, then columns (they become the rows after transposition)
    values.shuffleBlocks(size: 3)
    values = transpose(matrix: values)
    values.shuffleBlocks(size: 3)

    // Return the newly-generated grid
    return values
}

// Randomly generates a Sudoku with a certain number of clues. Starting with a
// full grid, a Sudoku can be generated by repeatedly removing elements until
// only a specified number of clues are left. Note that this strategy makes no
// guarantees that a proper (one unique solution) Sudoku is created, only that
// at least one solution exists (the full starting grid).
public func generateSudoku(clues: Int) -> [[Int]] {
    // Start with a full grid
    var grid = generateFullSudokuGrid()

    // Remove elements
    var elementsRemoved = 0
    while 81 - elementsRemoved > clues {
        // Select a random element
        let randomRow = Int.random(in: 0...8)
        let randomCol = Int.random(in: 0...8)
        // Set to 0 (remove value) if not set already
        if grid[randomRow][randomCol] != 0 {
            grid[randomRow][randomCol] = 0
            elementsRemoved += 1
        }
    }

    return grid
}

extension Array {

    // An Array extenstion with mutating instance methods enables adding extra
    // functionality that will be useful for generating Sudokus.
    // https://docs.swift.org/swift-book/documentation/the-swift-programming-language/extensions/#Mutating-Instance-Methods

    // Randomly rearrange the array's elements by swapping each index with
    // another chosen at random
    mutating func shuffle() {
        for currentIndex in 0..<self.count {
            let randomIndex = Int.random(in: 0..<self.count)
            self.swapElements(indexA: currentIndex, indexB: randomIndex)
        }
    }

    // Like shuffle(), but treats "blocks" of elements in an array as a
    // single unit
    mutating func shuffleBlocks(size: Int) {
        let blockCount = self.count/size
        for currentBlock in 0..<blockCount {
            let randomBlock = Int.random(in: 0..<blockCount)
            for i in 0..<size {
                self.swapElements(
                    indexA: i + (currentBlock * size),
                    indexB: i + (randomBlock * size)
                )
            }
        }
    }

    // Swap the two elements at the specified indices
    mutating func swapElements(indexA: Int, indexB: Int) {
        let temp = self[indexA]
        self[indexA] = self[indexB]
        self[indexB] = temp
    }

    // Rotate an array's elements by the specified number of positions and
    // return the new array
    mutating func rotate(by: Int) -> Array {
        var newArray = self
        var rotations = 0
        while rotations < by {
            newArray.append(newArray.remove(at: 0))
            rotations += 1
        }
        return newArray
    }

}

func transpose<T>(matrix: [[T]]) -> [[T]] {
    var newMatrix = [[T]]()
    // Iterate columns and map each original row
    // into the values from the current column
    for column in 0..<matrix[0].count {
        newMatrix.append(matrix.map{$0[column]})
    }
    return newMatrix
}
